"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Role = exports.PermissionType = exports.Permission = exports.User = exports.UserAddOptions = void 0;
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.23.4
 * source: auth.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
const pb_1 = require("google-protobuf");
class UserAddOptions extends pb_1.Message {
    #one_of_decls = [];
    constructor(data) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("no_password" in data && data.no_password != undefined) {
                this.no_password = data.no_password;
            }
        }
    }
    get no_password() {
        return pb_1.Message.getFieldWithDefault(this, 1, false);
    }
    set no_password(value) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data) {
        const message = new UserAddOptions({});
        if (data.no_password != null) {
            message.no_password = data.no_password;
        }
        return message;
    }
    toObject() {
        const data = {};
        if (this.no_password != null) {
            data.no_password = this.no_password;
        }
        return data;
    }
    serialize(w) {
        const writer = w || new pb_1.BinaryWriter();
        if (this.no_password != false)
            writer.writeBool(1, this.no_password);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes) {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UserAddOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.no_password = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary() {
        return this.serialize();
    }
    static deserializeBinary(bytes) {
        return UserAddOptions.deserialize(bytes);
    }
}
exports.UserAddOptions = UserAddOptions;
class User extends pb_1.Message {
    #one_of_decls = [];
    constructor(data) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("password" in data && data.password != undefined) {
                this.password = data.password;
            }
            if ("roles" in data && data.roles != undefined) {
                this.roles = data.roles;
            }
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
    }
    set name(value) {
        pb_1.Message.setField(this, 1, value);
    }
    get password() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
    }
    set password(value) {
        pb_1.Message.setField(this, 2, value);
    }
    get roles() {
        return pb_1.Message.getFieldWithDefault(this, 3, []);
    }
    set roles(value) {
        pb_1.Message.setField(this, 3, value);
    }
    get options() {
        return pb_1.Message.getWrapperField(this, UserAddOptions, 4);
    }
    set options(value) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_options() {
        return pb_1.Message.getField(this, 4) != null;
    }
    static fromObject(data) {
        const message = new User({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.password != null) {
            message.password = data.password;
        }
        if (data.roles != null) {
            message.roles = data.roles;
        }
        if (data.options != null) {
            message.options = UserAddOptions.fromObject(data.options);
        }
        return message;
    }
    toObject() {
        const data = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.password != null) {
            data.password = this.password;
        }
        if (this.roles != null) {
            data.roles = this.roles;
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        return data;
    }
    serialize(w) {
        const writer = w || new pb_1.BinaryWriter();
        if (this.name.length)
            writer.writeBytes(1, this.name);
        if (this.password.length)
            writer.writeBytes(2, this.password);
        if (this.roles.length)
            writer.writeRepeatedString(3, this.roles);
        if (this.has_options)
            writer.writeMessage(4, this.options, () => this.options.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes) {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new User();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readBytes();
                    break;
                case 2:
                    message.password = reader.readBytes();
                    break;
                case 3:
                    pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                    break;
                case 4:
                    reader.readMessage(message.options, () => message.options = UserAddOptions.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary() {
        return this.serialize();
    }
    static deserializeBinary(bytes) {
        return User.deserialize(bytes);
    }
}
exports.User = User;
class Permission extends pb_1.Message {
    #one_of_decls = [];
    constructor(data) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("permType" in data && data.permType != undefined) {
                this.permType = data.permType;
            }
            if ("key" in data && data.key != undefined) {
                this.key = data.key;
            }
            if ("range_end" in data && data.range_end != undefined) {
                this.range_end = data.range_end;
            }
        }
    }
    get permType() {
        return pb_1.Message.getFieldWithDefault(this, 1, PermissionType.Read);
    }
    set permType(value) {
        pb_1.Message.setField(this, 1, value);
    }
    get key() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
    }
    set key(value) {
        pb_1.Message.setField(this, 2, value);
    }
    get range_end() {
        return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
    }
    set range_end(value) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data) {
        const message = new Permission({});
        if (data.permType != null) {
            message.permType = data.permType;
        }
        if (data.key != null) {
            message.key = data.key;
        }
        if (data.range_end != null) {
            message.range_end = data.range_end;
        }
        return message;
    }
    toObject() {
        const data = {};
        if (this.permType != null) {
            data.permType = this.permType;
        }
        if (this.key != null) {
            data.key = this.key;
        }
        if (this.range_end != null) {
            data.range_end = this.range_end;
        }
        return data;
    }
    serialize(w) {
        const writer = w || new pb_1.BinaryWriter();
        if (this.permType != PermissionType.Read)
            writer.writeEnum(1, this.permType);
        if (this.key.length)
            writer.writeBytes(2, this.key);
        if (this.range_end.length)
            writer.writeBytes(3, this.range_end);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes) {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Permission();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.permType = reader.readEnum();
                    break;
                case 2:
                    message.key = reader.readBytes();
                    break;
                case 3:
                    message.range_end = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary() {
        return this.serialize();
    }
    static deserializeBinary(bytes) {
        return Permission.deserialize(bytes);
    }
}
exports.Permission = Permission;
var PermissionType;
(function (PermissionType) {
    PermissionType[PermissionType["Read"] = 0] = "Read";
    PermissionType[PermissionType["Write"] = 1] = "Write";
    PermissionType[PermissionType["Readwrite"] = 2] = "Readwrite";
})(PermissionType || (exports.PermissionType = PermissionType = {}));
class Role extends pb_1.Message {
    #one_of_decls = [];
    constructor(data) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("keyPermission" in data && data.keyPermission != undefined) {
                this.keyPermission = data.keyPermission;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
    }
    set name(value) {
        pb_1.Message.setField(this, 1, value);
    }
    get keyPermission() {
        return pb_1.Message.getRepeatedWrapperField(this, Permission, 2);
    }
    set keyPermission(value) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data) {
        const message = new Role({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.keyPermission != null) {
            message.keyPermission = data.keyPermission.map(item => Permission.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.keyPermission != null) {
            data.keyPermission = this.keyPermission.map((item) => item.toObject());
        }
        return data;
    }
    serialize(w) {
        const writer = w || new pb_1.BinaryWriter();
        if (this.name.length)
            writer.writeBytes(1, this.name);
        if (this.keyPermission.length)
            writer.writeRepeatedMessage(2, this.keyPermission, (item) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes) {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Role();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readBytes();
                    break;
                case 2:
                    reader.readMessage(message.keyPermission, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Permission.deserialize(reader), Permission));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary() {
        return this.serialize();
    }
    static deserializeBinary(bytes) {
        return Role.deserialize(bytes);
    }
}
exports.Role = Role;
