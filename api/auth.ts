/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.23.4
 * source: auth.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export class UserAddOptions extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        no_password?: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("no_password" in data && data.no_password != undefined) {
                this.no_password = data.no_password;
            }
        }
    }
    get no_password() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set no_password(value: boolean) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        no_password?: boolean;
    }): UserAddOptions {
        const message = new UserAddOptions({});
        if (data.no_password != null) {
            message.no_password = data.no_password;
        }
        return message;
    }
    toObject() {
        const data: {
            no_password?: boolean;
        } = {};
        if (this.no_password != null) {
            data.no_password = this.no_password;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.no_password != false)
            writer.writeBool(1, this.no_password);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UserAddOptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UserAddOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.no_password = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): UserAddOptions {
        return UserAddOptions.deserialize(bytes);
    }
}
export class User extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: Uint8Array;
        password?: Uint8Array;
        roles?: string[];
        options?: UserAddOptions;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("password" in data && data.password != undefined) {
                this.password = data.password;
            }
            if ("roles" in data && data.roles != undefined) {
                this.roles = data.roles;
            }
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
    }
    set name(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get password() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
    }
    set password(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get roles() {
        return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
    }
    set roles(value: string[]) {
        pb_1.Message.setField(this, 3, value);
    }
    get options() {
        return pb_1.Message.getWrapperField(this, UserAddOptions, 4) as UserAddOptions;
    }
    set options(value: UserAddOptions) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_options() {
        return pb_1.Message.getField(this, 4) != null;
    }
    static fromObject(data: {
        name?: Uint8Array;
        password?: Uint8Array;
        roles?: string[];
        options?: ReturnType<typeof UserAddOptions.prototype.toObject>;
    }): User {
        const message = new User({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.password != null) {
            message.password = data.password;
        }
        if (data.roles != null) {
            message.roles = data.roles;
        }
        if (data.options != null) {
            message.options = UserAddOptions.fromObject(data.options);
        }
        return message;
    }
    toObject() {
        const data: {
            name?: Uint8Array;
            password?: Uint8Array;
            roles?: string[];
            options?: ReturnType<typeof UserAddOptions.prototype.toObject>;
        } = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.password != null) {
            data.password = this.password;
        }
        if (this.roles != null) {
            data.roles = this.roles;
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.name.length)
            writer.writeBytes(1, this.name);
        if (this.password.length)
            writer.writeBytes(2, this.password);
        if (this.roles.length)
            writer.writeRepeatedString(3, this.roles);
        if (this.has_options)
            writer.writeMessage(4, this.options, () => this.options.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): User {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new User();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readBytes();
                    break;
                case 2:
                    message.password = reader.readBytes();
                    break;
                case 3:
                    pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                    break;
                case 4:
                    reader.readMessage(message.options, () => message.options = UserAddOptions.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): User {
        return User.deserialize(bytes);
    }
}
export class Permission extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        permType?: PermissionType;
        key?: Uint8Array;
        range_end?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("permType" in data && data.permType != undefined) {
                this.permType = data.permType;
            }
            if ("key" in data && data.key != undefined) {
                this.key = data.key;
            }
            if ("range_end" in data && data.range_end != undefined) {
                this.range_end = data.range_end;
            }
        }
    }
    get permType() {
        return pb_1.Message.getFieldWithDefault(this, 1, PermissionType.Read) as PermissionType;
    }
    set permType(value: PermissionType) {
        pb_1.Message.setField(this, 1, value);
    }
    get key() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
    }
    set key(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get range_end() {
        return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
    }
    set range_end(value: Uint8Array) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        permType?: PermissionType;
        key?: Uint8Array;
        range_end?: Uint8Array;
    }): Permission {
        const message = new Permission({});
        if (data.permType != null) {
            message.permType = data.permType;
        }
        if (data.key != null) {
            message.key = data.key;
        }
        if (data.range_end != null) {
            message.range_end = data.range_end;
        }
        return message;
    }
    toObject() {
        const data: {
            permType?: PermissionType;
            key?: Uint8Array;
            range_end?: Uint8Array;
        } = {};
        if (this.permType != null) {
            data.permType = this.permType;
        }
        if (this.key != null) {
            data.key = this.key;
        }
        if (this.range_end != null) {
            data.range_end = this.range_end;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.permType != PermissionType.Read)
            writer.writeEnum(1, this.permType);
        if (this.key.length)
            writer.writeBytes(2, this.key);
        if (this.range_end.length)
            writer.writeBytes(3, this.range_end);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Permission {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Permission();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.permType = reader.readEnum();
                    break;
                case 2:
                    message.key = reader.readBytes();
                    break;
                case 3:
                    message.range_end = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): Permission {
        return Permission.deserialize(bytes);
    }
}
export enum PermissionType {
    Read = 0,
    Write = 1,
    Readwrite = 2
}
export class Role extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: Uint8Array;
        keyPermission?: Permission[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("keyPermission" in data && data.keyPermission != undefined) {
                this.keyPermission = data.keyPermission;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
    }
    set name(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get keyPermission() {
        return pb_1.Message.getRepeatedWrapperField(this, Permission, 2) as Permission[];
    }
    set keyPermission(value: Permission[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
        name?: Uint8Array;
        keyPermission?: ReturnType<typeof Permission.prototype.toObject>[];
    }): Role {
        const message = new Role({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.keyPermission != null) {
            message.keyPermission = data.keyPermission.map(item => Permission.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            name?: Uint8Array;
            keyPermission?: ReturnType<typeof Permission.prototype.toObject>[];
        } = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.keyPermission != null) {
            data.keyPermission = this.keyPermission.map((item: Permission) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.name.length)
            writer.writeBytes(1, this.name);
        if (this.keyPermission.length)
            writer.writeRepeatedMessage(2, this.keyPermission, (item: Permission) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Role {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Role();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readBytes();
                    break;
                case 2:
                    reader.readMessage(message.keyPermission, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Permission.deserialize(reader), Permission));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): Role {
        return Role.deserialize(bytes);
    }
}
